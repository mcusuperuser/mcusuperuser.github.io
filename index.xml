<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Embedded C for Arm Cortex-M Microcontrollers</title>
    <link>https://mcusuperuser.github.io/</link>
    <description>Recent content on Embedded C for Arm Cortex-M Microcontrollers</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 23 Dec 2020 22:38:19 +0100</lastBuildDate><atom:link href="https://mcusuperuser.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introduction</title>
      <link>https://mcusuperuser.github.io/arrays/introduction/</link>
      <pubDate>Wed, 23 Dec 2020 22:38:04 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/arrays/introduction/</guid>
      <description>Arrays may contain any number of elements which must be of the same type. The array index is zero based and the size of the array (number of elements) must be specified at the array declaration.
Syntax
type arrayIdentifier[size]; The size refers to the number of elements and must be a constant integer.
Code example
int n[100]; // an array that holds 100 integer values  char c[26]; // an array that holds 26 characters Arrays may be initialized when declared using a list:</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://mcusuperuser.github.io/storage/introduction/</link>
      <pubDate>Wed, 23 Dec 2020 22:30:52 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/storage/introduction/</guid>
      <description>In C, four storage classes are available:
 Automatic Static External Register  Syntax
storage_class type identifier; </description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://mcusuperuser.github.io/func/functions/</link>
      <pubDate>Wed, 23 Dec 2020 22:19:42 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/func/functions/</guid>
      <description>Functions provide a way to modularize code and make it easier to maintain. Also, functions promote code reuse.
All C programs have one (at least the main() function is required) or more functions.
Functions can accept parameters from the code that calls them.
Functions usually return a single value.
Functions help to organize a program into logical, manageable segments.
Syntax
type identifier (type1 arg1, type2 arg2, ..., typen argn) { declarations // body  statements // body  return expression; // body } Where:</description>
    </item>
    
    <item>
      <title>For loop</title>
      <link>https://mcusuperuser.github.io/loops/for/</link>
      <pubDate>Wed, 23 Dec 2020 22:07:56 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/loops/for/</guid>
      <description>A for loop checks the loop condition at the top and automatically executes the iterator at the bottom of the loop.
Syntax
for (expression1; expression2; expression 3) statement The expression1 initializes the loop count variable once (e.g. n= 0). The expression2 is the test condition. The loop will continue while this is true (e.g. n &amp;lt;= 10). The expression3 is executed at the end of each iteration; usually to modify the loop count variable (e.</description>
    </item>
    
    <item>
      <title>Boolean expressions</title>
      <link>https://mcusuperuser.github.io/decisions/boolean/</link>
      <pubDate>Wed, 23 Dec 2020 21:58:56 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/decisions/boolean/</guid>
      <description>C (unlike C++) does not have a boolean data type. As shown in the table in chapter Data types, you can use _Bool for that. But the usual convention is that any boolean expression returns integer values:
 0 if an expression evaluates as FALSE non-zero if it evaluates as TRUE (usually 1, but this is not guaranteed)  Code example
int main (void) { int a = 3, b, c; c = (a &amp;gt; 2); // c = 1 (TRUE)  b = (a &amp;lt; 1); // b = 0 (FALSE) } Express it differently Expressions can be written in different ways which all lead to the same result (are evaluated similarly).</description>
    </item>
    
    <item>
      <title>Expression statements</title>
      <link>https://mcusuperuser.github.io/exprstat/expression/</link>
      <pubDate>Wed, 23 Dec 2020 21:52:18 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/exprstat/expression/</guid>
      <description>An expression statement is an expression followed by a semicolon (;). The execution of the statements causes the expression to be evaluated.
Code example
a = 0; a++; b = 3 + c; y = (a * x) + b; printf(&amp;#34;Speed = %f&amp;#34;, x); ; // the semicolon itself is an expression </description>
    </item>
    
    <item>
      <title>Constants</title>
      <link>https://mcusuperuser.github.io/constlit/constants/</link>
      <pubDate>Wed, 23 Dec 2020 21:13:17 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/constlit/constants/</guid>
      <description>Constants, as the name implies, never change their value which makes development changes easy and eliminates the use of &amp;ldquo;magic numbers&amp;rdquo;.
Syntax
There are two ways to declare a constant:
#define identifierName value  const type identifierName value;  The identifierName is the constant, while the value is the literal. The first way is very efficient for an embedded system, as it does not consume any memory in the microcontroller. Using the #define, you declare a text substitution label, which means that each instance of identifierName will be replaced with value by the preprocessor unless identifierName is inside a string.</description>
    </item>
    
    <item>
      <title>Variables</title>
      <link>https://mcusuperuser.github.io/vars/variables/</link>
      <pubDate>Wed, 23 Dec 2020 16:41:49 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/vars/variables/</guid>
      <description>A variable is a kind of bucket that you can use to hold program data.
Variable declarations consist of a data type and a unique identifier (name).
Code example
int myVar; myVar = 42; The data type determines the size of the memory location that is used to store the variable and determines how the value of the variable is interpreted.
Code example
int myVar; char myLetter; float myFLoat, </description>
    </item>
    
    <item>
      <title>Accessing peripherals</title>
      <link>https://mcusuperuser.github.io/peripherals/accessing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/peripherals/accessing/</guid>
      <description>Each peripheral provides a data type definition with a name that is composed of:
 an optional prefix &amp;lt;device abbreviation&amp;gt;_ &amp;lt;peripheral name&amp;gt; postfix _Type or _TypeDef to identify a type definition.  To access the peripheral registers and related function in a device, the files device.h and core_cm#.h define as a minimum:
 The register layout typedef for each peripheral that defines all register names. RESERVED is used to introduce space into the structure for adjusting the addresses of the peripheral registers.</description>
    </item>
    
    <item>
      <title>Arithmetic operators</title>
      <link>https://mcusuperuser.github.io/operators/arithmetic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/operators/arithmetic/</guid>
      <description>Arithmetic operators are used to perform arithmetic/mathematical operations on operands. Arithmetic operators are of two distinct types:
 Binary Operators work on two operands: +, -, *, /, % Unary Operators work on a single operand: +, -, ++, &amp;ndash;     Operator Operation Example Result     * Multiplication a * b Product of a and b   / Division a / b Quotient of a and b   % Modulo a % b Remainder of a divided by b   + Addition a + b Sum of a and b   - Subtraction a - b Difference of a and b   - (unary) Negative -a Negative value of a   + (unary) Positive +a Value of a    Division operator If both operands are of an integer type, the result will be an integer type as well (valid for int and char).</description>
    </item>
    
    <item>
      <title>Enumeration declaration</title>
      <link>https://mcusuperuser.github.io/enums/declaration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/enums/declaration/</guid>
      <description>Enumerations:
 Are unique integer data types May only contain a specified list of values Values are specified as symbolic constants  Syntax
enum typeName { label0, label1, ..., labeln } The compiler sets label0 = 0, label1 = 1, labeln = n.
Code example
enum month {JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC}; You can assign a specific value to any label.</description>
    </item>
    
    <item>
      <title>How to use printf()</title>
      <link>https://mcusuperuser.github.io/printf/use/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/printf/use/</guid>
      <description>Syntax
printf(ControlString, arg1, ..., argn); Everything within the ControlString is printed verbatim except %d&amp;rsquo;s which are replaced by the argument values from the list.
Code example
int n = 1, m = 7; printf(&amp;#34;n = %d\nm = %d\n&amp;#34;, n, m); The output is:
n = 1 m = 7 %d is the conversion character.
\n is a special character.
See next section for a list of conversion characters.</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://mcusuperuser.github.io/funcpointers/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/funcpointers/introduction/</guid>
      <description>A function pointer is declared much like a function prototype:
Syntax
int (*fp) (int a); This is the declaration of a function pointer called fp.
The function it points to must take one int parameter and must return an int.
Initialization Initialize a function pointer by setting the pointer name equal to the function name:
Code example
int (*fp) (int a); // Function pointer int foo (int a); // Function prototype  // Initialization: fp = foo; // fp points to foo </description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://mcusuperuser.github.io/unions/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/unions/introduction/</guid>
      <description>A union allows the same memory location to be used for different data types. The amount of memory that is allocated for the union is determined by its largest member. This saves space, especially for large structures where the programmer can be sure that the same members never occur at the same time.
Unions:
 may contain any number of members which may be of any data type. are as large as their largest member.</description>
    </item>
    
    <item>
      <title>Pointer declaration</title>
      <link>https://mcusuperuser.github.io/pointers/declaration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/pointers/declaration/</guid>
      <description>As any other variable, you need to declare a pointer. Furthermore, you have to initialize a pointer before you can use it.
You declare a pointer just like any other variable:
Syntax
type *name; type can be any C type (such as char, int, or float for example).
name is the name of the pointer variable.
The * makes the variable a pointer.
Pointers are usually described as &amp;ldquo;a pointer to type&amp;rdquo;</description>
    </item>
    
    <item>
      <title>Simple macros</title>
      <link>https://mcusuperuser.github.io/macros/simple/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/macros/simple/</guid>
      <description>Macros:
 Are evaluated by the preprocessor Cannot be executed by themselves Are used to control the generation of code before the compilation process Provide valuable shortcuts  Syntax
#define label text Every instance of label in the current file will be replaced by text.
text can be anything you can type into your editor.
Arithmetic expressions are evaluated at compile time.
Code example (system_ARMCM3.c)
/*---------------------------------------------------------------------------- Define clocks *----------------------------------------------------------------------------*/ #define XTAL (50000000UL) /* Oscillator frequency */#define SYSTEM_CLOCK (XTAL / 2U)  /*---------------------------------------------------------------------------- System Core Clock Variable *----------------------------------------------------------------------------*/ uint32_t SystemCoreClock = SYSTEM_CLOCK; /* System Core Clock Frequency */ </description>
    </item>
    
    <item>
      <title>Structure definition</title>
      <link>https://mcusuperuser.github.io/structs/definition/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/structs/definition/</guid>
      <description>Syntax
struct structName { type1 memberName1; // Members are declared just  ... // like odinary variables  typen memberNamen; } </description>
    </item>
    
    <item>
      <title>Using bit fields</title>
      <link>https://mcusuperuser.github.io/bitfields/using/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/bitfields/using/</guid>
      <description>Syntax
struct structName { unsigned int memberName1: bitWidth; ... unsigned int memberNamen: bitWidth; } Code example
// bit field struct may be celared normally or as a typedef typedef struct { unsigned int x:10; unsigned int y:20; } myBits; Using bit fields Code example
struct myByteBits { unsigned int volts: 1; unsigned int amps: 1; unsigned int ohm: 1; unsigned int humid: 3; unsigned int temp: 2; } a; int main (void) { a.</description>
    </item>
    
    <item>
      <title>Multidimensional arrays</title>
      <link>https://mcusuperuser.github.io/arrays/multidim/</link>
      <pubDate>Wed, 23 Dec 2020 22:38:14 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/arrays/multidim/</guid>
      <description>Arrays may have any number of dimensions that are added in the declaration:
Syntax
type arrayIdentifier[size0]...[sizen]; Code example
int n[3][3]; // 3 x 3 array for 9 integers  float c[10][10][10]; // 10 x 10 x 10 array for 1000 floats Multidimensional arrays are initialized with lists within a list:
Syntax
type arrayIdentifier[size0]...[sizen] = {{item, ..., item}, ... {item, ..., item}}; Code example
char c[3][3] = {{&amp;#39;o&amp;#39;,&amp;#39;x&amp;#39;,&amp;#39;o&amp;#39;}, {&amp;#39;x&amp;#39;,&amp;#39;x&amp;#39;,&amp;#39;x&amp;#39;}, {&amp;#39;o&amp;#39;,&amp;#39;x&amp;#39;,&amp;#39;o&amp;#39;}}; int n[2][3][4] = {{{0, 1, 2, 3},{4, 5, 6, 7},{8, 9, 10, 11}}, {{12, 13, 14, 15},{16, 17, 18, 19},{20,21, 22, 23}}}; Visualizing 2-dimensional arrays Visualizing 3-dimensional arrays </description>
    </item>
    
    <item>
      <title>Auto variables</title>
      <link>https://mcusuperuser.github.io/storage/auto/</link>
      <pubDate>Wed, 23 Dec 2020 22:28:32 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/storage/auto/</guid>
      <description>The default storage class for all variables declared inside a function or a block is auto. Auto variables can be only accessed within the block/function they have been declared and not outside them. To access them outside their scope, use a pointer to the very exact memory location where the variables resides. They are assigned a garbage value by default whenever they are declared. As auto is the default, the keyword auto is rarely used.</description>
    </item>
    
    <item>
      <title>Return data type</title>
      <link>https://mcusuperuser.github.io/func/return/</link>
      <pubDate>Wed, 23 Dec 2020 22:17:13 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/func/return/</guid>
      <description>A function&amp;rsquo;s type must match the type of data in the return expression. A function may have multiple return statements (of the same type), but only one will be executed. The function type is void if the return statement has no expression or is not present at all. This is also known as a procedure function, since nothing is returned. Functions can return any type except arrays and functions. We can get around this limitation by returning a pointer to an array or a pointer to a function.</description>
    </item>
    
    <item>
      <title>While loop</title>
      <link>https://mcusuperuser.github.io/loops/while/</link>
      <pubDate>Wed, 23 Dec 2020 22:08:01 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/loops/while/</guid>
      <description>A while loop checks the loop condition at the top; you must create the iterator if needed.
Syntax
while (expression) statement If the expression is true, the statement will be executed. Afterwards, the expression will be reevaluated to determine whether or not to execute the statement again. It is possible that the statement will never be executed if the expression is false when it is evaluated for the first time.</description>
    </item>
    
    <item>
      <title>if statement</title>
      <link>https://mcusuperuser.github.io/decisions/if/</link>
      <pubDate>Wed, 23 Dec 2020 21:59:01 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/decisions/if/</guid>
      <description>Syntax
if (expression) statement The expression is evaluated in a boolean fashion. If it is true, the statement is executed.
The statement can also be a compound/block statement.
Code example
#define BUTTONPRESSED 1  int main (void) { if (BUTTONPRESSED) { printf(&amp;#34;Button is pressed\n&amp;#34;); } } if (a) vs. if (a == 1) Not only laziness commands the usage of if (a). This C code will also lead to reduced assembly code size, as it only has to test for not being equal to 0:</description>
    </item>
    
    <item>
      <title>Compound or block statements</title>
      <link>https://mcusuperuser.github.io/exprstat/compound/</link>
      <pubDate>Wed, 23 Dec 2020 21:52:24 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/exprstat/compound/</guid>
      <description>A compound statement is a group of statements enclosed within a pair of curly braces ({ }) and is often also called a block statement. The statements within the block may be of any statement type (including (again) compound statements). This allows statements to be embedded or nested within other statements. A compound statement does not end with a semicolon after the closing }.
Code example
{ a = 0; a++; b = 3 + c; y = (a * x) + b; printf(&amp;#34;Speed = %f&amp;#34;, x); } </description>
    </item>
    
    <item>
      <title>Identifiers</title>
      <link>https://mcusuperuser.github.io/vars/identifiers/</link>
      <pubDate>Wed, 23 Dec 2020 16:41:55 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/vars/identifiers/</guid>
      <description> Valid characters in identifiers are &amp;lsquo;_&amp;rsquo;, &amp;lsquo;a&amp;rsquo; to &amp;lsquo;z&amp;rsquo;, &amp;lsquo;A&amp;rsquo; to &amp;lsquo;Z&amp;rsquo;, and &amp;lsquo;0&amp;rsquo; to &amp;lsquo;9&amp;rsquo; (not allowed for the first character). Identifiers are case sensitive, so myVar is not the same as myvar! You must not use keywords of the C language as identifiers. The Arm compiler provides additional keywords that are extensions to the C/C++ standards and must also not be used as identifiers.  ANSI C keywords             auto break case char const   continue default do double else   enum extern float for goto   if int long register return   short signed sizeof static struct   switch typedef union unsigned void   volatile while       Arm compiler 5 keywords and operators           __align __int64 __svc   __ALIGNOF__ __INTADDR__ __svc_indirect   __asm __irq __svc_indirect_r7   __declspec __packed __value_in_regs   __forceinline __pure __weak   __global_reg __softfp __writeonly   __inline __smc     Arm compiler 6 (armclang) keywords and operators            __alignof__ __asm __declspec __inline    </description>
    </item>
    
    <item>
      <title>Block comment</title>
      <link>https://mcusuperuser.github.io/comments/block/</link>
      <pubDate>Wed, 23 Dec 2020 16:25:49 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/comments/block/</guid>
      <description>Syntax
/* This is a block comment. */  Block comments begin with /* and end with */. They can span multiple lines.  Code example
/*----------------------------------------------- * CMSIS-RTOS &amp;#39;main&amp;#39; function template *---------------------------------------------*/ #include &amp;#34;cmsis_os2.h&amp;#34; /* * main: initialize and start the system */ int main (void) { osKernelInitialize (); /* initialize RTOS */ LED_Initialize(); /* initialize LEDs */ /* create &amp;#39;thread&amp;#39; functions that start executing. Example: tid_name=osThreadCreate (osThread(name), NULL); */ osKernelStart (); /* start thread execution */ } </description>
    </item>
    
    <item>
      <title>Argument macros</title>
      <link>https://mcusuperuser.github.io/macros/argument/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/macros/argument/</guid>
      <description>Argument macros create function-like macros:
Syntax
#define label(arg1, ..., argn) code The code must fit on a single line. For multi-line macros use &amp;lsquo;\&amp;rsquo; to split lines Arguments are inserted into code as text substitutions Each instance of label() will be expanded into code
Code example (arm_math.h)
#define __SIMD32(addr) (*(__SIMD32_TYPE **) &amp;amp; (addr)) #define __SIMD32_CONST(addr) ( (__SIMD32_TYPE * ) (addr)) #define _SIMD32_OFFSET(addr) (*(__SIMD32_TYPE * ) (addr)) #define __SIMD64(addr) (*( int64_t **) &amp;amp; (addr)) </description>
    </item>
    
    <item>
      <title>Assignment operators</title>
      <link>https://mcusuperuser.github.io/operators/assignment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/operators/assignment/</guid>
      <description>Assignment operators are binary operators that modify the variable to their left using the value to their right, or in other words, they assign a value to a variable.
There are two types of assignment operators available:
Simple assignments Syntax
variable = expression
The expression is evaluated and the result is assigned to the variable.
Compound assignments Syntax
variable = variable operator expression
The variable is modified using the operator and the expression and the result is assigned to the variable.</description>
    </item>
    
    <item>
      <title>Calling a function via a function pointer</title>
      <link>https://mcusuperuser.github.io/funcpointers/calling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/funcpointers/calling/</guid>
      <description>The following two calls to the function are equivalent:
Code example
m = fp(a); // call via function pointer m = foo(a); // direct call to foo </description>
    </item>
    
    <item>
      <title>Conversion characters</title>
      <link>https://mcusuperuser.github.io/printf/conversion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/printf/conversion/</guid>
      <description>The following table lists all conversion characters of the printf() function:
   Conversion character Description     %c Single character   %s String (all characters until \0)   %d Signed decimal number   %# A 0x should precede a hexadecimal number   %u Unsigned decimal number   %o Unsigned octal number   %x Unsigned hexadecimal number with lowercase digits (1a4e)   %X As x, but with uppercase digits (1A4E)   %f Signed decimal value (floating point)   %e Signed decimal with exponent (1.</description>
    </item>
    
    <item>
      <title>Creating unions with typedefs</title>
      <link>https://mcusuperuser.github.io/unions/creating/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/unions/creating/</guid>
      <description>Syntax
typedef union unionTag { type1 memberName1; ... typen memberNamen; } typeName; Code example
// Union type to access the Application Program Status Register (APSR). typedef union { struct { uint32_t _reserved0:27; // bit: 0..26 Reserved  uint32_t Q:1; // bit: 27 Saturation condition flag  uint32_t V:1; // bit: 28 Overflow condition code flag  uint32_t C:1; // bit: 29 Carry condition code flag  uint32_t Z:1; // bit: 30 Zero condition code flag  uint32_t N:1; // bit: 31 Negative condition code flag  } b; // Structure used for bit access  uint32_t w; // Type used for word access } APSR_Type; </description>
    </item>
    
    <item>
      <title>Declaration of enumeration type variable</title>
      <link>https://mcusuperuser.github.io/enums/declarationtypevar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/enums/declarationtypevar/</guid>
      <description>Declared along with type
enum typeName { list_of_constants } variable_name1, ...; Declared independently
enum typeName variable_name1, ...; Code example
enum month {JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC} current_month; enum month current_month; </description>
    </item>
    
    <item>
      <title>Literals</title>
      <link>https://mcusuperuser.github.io/constlit/literals/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/constlit/literals/</guid>
      <description>A literal is the actual value (such as a number or character for example), that is assigned to a variable or constant. You can also use literals directly as a function parameter or as an operand in an expression. While both terms are often used interchangeably, they are not the same. A literal is a constant, but a constant is not a literal.
Types of literals The Arm assembler user&amp;rsquo;s guide states that &amp;ldquo;source code can contain numeric, string, Boolean, and single character literals&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Pointers and arrays</title>
      <link>https://mcusuperuser.github.io/pointers/andarrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/pointers/andarrays/</guid>
      <description>In general, array elements occupy consecutive locations in memory. Using this knowledge, we can use pointers to access array elements.
Initializing a pointer to an array Code example
int a[5] = {0, 1, 2, 3, 4}; // integer array int *p; // Create a pointer to an integer variable To initialize the pointer to the array, you can use three different (equal) methods:
Code example
p = a; // works only for arrays, as the array name (here: a) is the same as the address of its first element; Arm compiler will not complain p = &amp;amp;a; // works for arrays and variabls alike, but in case of an array, the Arm compiler will issue a warning p = &amp;amp;a[0]; // safe way to point to the first element; compiler will not complain To move to the next element of the array, simply increment the pointer:</description>
    </item>
    
    <item>
      <title>Reading, modifying, and writing bit fields in registers</title>
      <link>https://mcusuperuser.github.io/peripherals/readmodifywrite/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/peripherals/readmodifywrite/</guid>
      <description>How do we find the current value of the ICSR ISRPREEMPT bit? We read the register SCB, AND it (using &amp;amp;) with the mask, and then shift it right (using &amp;raquo;) by the shift value:
Code example
id = (SCB-&amp;gt;ICSR &amp;amp; SCB_ICSR_ISRPREEMPT_Msk) &amp;gt;&amp;gt; SCB_ICSR_ISRPREEMPT_Pos; How do we set fields NMIPENDSET and PENDSVSET in that register, leaving everything else as zero? We use the = assignment operator:
Code example
SCB-&amp;gt;ICSR = SCB_ICSR_NMIPENDSET_Msk | SCB_ICSR_PENDSVSET_Msk; How do we set fields NMIPENDSET and PENDSVSET in that register without modifying anything else?</description>
    </item>
    
    <item>
      <title>Variable declaration</title>
      <link>https://mcusuperuser.github.io/structs/declaration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/structs/declaration/</guid>
      <description>There are two ways to declare a structure variable:
 At structure definition:  Syntax
struct structName { type1 memberName1; // Members are declared just  ... // like odinary variables  typen memberNamen; } variableName1, ..., variableNamen; Code example
// structure to handle color values struct rgb { int red; int green; int blue; } color; // declare color of type rgb If the structure has already been defined:  Syntax</description>
    </item>
    
    <item>
      <title>Strings</title>
      <link>https://mcusuperuser.github.io/arrays/strings/</link>
      <pubDate>Wed, 23 Dec 2020 22:38:19 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/arrays/strings/</guid>
      <description>Strings are arrays of char whose last element is a null character \0 with an ASCII value of 0. As C has no native string data type, strings must always be treated as character arrays.
Strings:
 are enclosed in double quotes: &amp;ldquo;string&amp;rdquo; are terminated by a null character \0 must be manipulated as arrays of characters (treated element by element) may be initialized with a string literal  Creating a string character array Syntax</description>
    </item>
    
    <item>
      <title>Static variables</title>
      <link>https://mcusuperuser.github.io/storage/static/</link>
      <pubDate>Wed, 23 Dec 2020 22:28:37 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/storage/static/</guid>
      <description>Variables declared as static preserve their value even after they are out of their scope, as they are given a permanent address in memory. They are created/initialized once when the program starts and are only destroyed when the program ends! Their scope is local to the function to which they were defined. Global static variables can be accessed anywhere in the program. By default, they are assigned the value 0 by the compiler.</description>
    </item>
    
    <item>
      <title>Parameters</title>
      <link>https://mcusuperuser.github.io/func/parameters/</link>
      <pubDate>Wed, 23 Dec 2020 22:17:22 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/func/parameters/</guid>
      <description>A function&amp;rsquo;s parameters are declared just like ordinary variables, but in a comma separated list inside the parentheses. The parameter names are only valid inside the function (local to the function). The list may mix different data types. Parameters of the same type must be declared separately (as separation using commas will not work here). If no parameters are required, use the keyword void in place of the parameter list when defining the function.</description>
    </item>
    
    <item>
      <title>do while loop</title>
      <link>https://mcusuperuser.github.io/loops/do-while/</link>
      <pubDate>Wed, 23 Dec 2020 22:08:07 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/loops/do-while/</guid>
      <description>A do .. while loop checks the loop condition at the bottom; you must create the iterator if needed.
Syntax
do statement while (expression); The statement is executed and then the expression is evaluated to determine whether or not to execute the statement again. The statement will always execute at least once, even if the expression is false when the loop starts.
Code example
int n = 0; do { printf(&amp;#34;Loop iteration %d\n&amp;#34;, n); } while (n &amp;lt; 5); Output</description>
    </item>
    
    <item>
      <title>switch statement</title>
      <link>https://mcusuperuser.github.io/decisions/switch/</link>
      <pubDate>Wed, 23 Dec 2020 21:59:06 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/decisions/switch/</guid>
      <description>Syntax
switch (expression) { case const-expr1: statements1 : case const-exprn: statementsn default: statementsn+1 } The expression is evaluated and tested for a match with the const-expr in each case clause. The statement(s) in the matching case clause is/are executed.
Each statement falls through to the next statement. This is the default behavior of the switch statement.
Adding a break statement to each statement block will eliminate fall through, allowing only one case clause&amp;rsquo;s statement block to be executed.</description>
    </item>
    
    <item>
      <title>Control statements</title>
      <link>https://mcusuperuser.github.io/exprstat/control/</link>
      <pubDate>Wed, 23 Dec 2020 21:52:30 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/exprstat/control/</guid>
      <description>Control statements are used for loops, branches and logical tests and often require other statements to be embedded within them. We will take a closer look at them in the chapter Decision making.
Code example
while (1) { // do something here } </description>
    </item>
    
    <item>
      <title>Datatypes</title>
      <link>https://mcusuperuser.github.io/vars/datatypes/</link>
      <pubDate>Wed, 23 Dec 2020 16:42:03 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/vars/datatypes/</guid>
      <description>C provides various data types. Normally, you would use:
 int for most variables and things that you can count, such as loop counts, events, and apples char for characters and strings float for measurable things that require decimal numbers, such as distance, temperature, or voltage uint32_t for bit manipulations, especially on 32-bit registers The appropriate &amp;lt;stdint.h&amp;gt;/&amp;lt;arm_math.h&amp;gt; types for storing and working with data explicitly meeting your needs (for example if you require that an integer has exactly N bits)  Size and alignment of basic data types in Arm C/C++    ANSI C Type stdint.</description>
    </item>
    
    <item>
      <title>Single line comment</title>
      <link>https://mcusuperuser.github.io/comments/single/</link>
      <pubDate>Wed, 23 Dec 2020 16:25:54 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/comments/single/</guid>
      <description>Syntax
// This is a single line comment.  Single line comments begin with // and run until the end of the current line. They can not span multiple lines.  Code example
//----------------------------------------------- // CMSIS-RTOS &amp;#39;main&amp;#39; function template //-----------------------------------------------  #include &amp;#34;cmsis_os2.h&amp;#34; // main: initialize and start the system  int main (void) { osKernelInitialize (); // initialize RTOS  LED_Initialize(); // initialize LEDs  // create &amp;#39;thread&amp;#39; functions that start executing  // Example:  // tid_name=osThreadCreate (osThread(name), NULL);  osKernelStart (); // start thread execution } </description>
    </item>
    
    <item>
      <title>Alternative mechanism</title>
      <link>https://mcusuperuser.github.io/peripherals/alternative/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/peripherals/alternative/</guid>
      <description>Using the CMSIS macros _VAL2FLD(field, value) and _FLD2VAL(field, value) you can access bit fields more easily.
Code example
id = _FLD2VAL(SCB_CPUID_REVISION, SCB-&amp;gt;CPUID); // uses the #define&amp;#39;s _Pos and _Msk of the related bit field to extract the value of a bit field from a register.  SCB-&amp;gt;CPUID = _VAL2FLD(SCB_CPUID_REVISION, 0x3) | _VAL2FLD(SCB_CPUID_VARIANT, 0x3); // uses the #define&amp;#39;s _Pos and _Msk of the related bit field to shift bit-field values for assigning to a register.</description>
    </item>
    
    <item>
      <title>Passing a function to a function</title>
      <link>https://mcusuperuser.github.io/funcpointers/passing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/funcpointers/passing/</guid>
      <description>The following example shows the basic concept:
Code example
int a, b; int add(int n, int m); // Function prototype int sub(int n, int m); // Function prototype  //Function definition with function pointer parameter int foobar(int n, int n, int (*fp)(int, int)) { return fp(n, m); // Call function passed by pointer } void main(void) { a = foobar (2, 72, &amp;amp;add); // Pass address of add  b = foobar (31, 2, &amp;amp;sub); // Pass address of sub } </description>
    </item>
    
    <item>
      <title>Pointers and functions</title>
      <link>https://mcusuperuser.github.io/pointers/andfunctions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/pointers/andfunctions/</guid>
      <description>In general, functions operate on copies of the data that is passed to them. This is called pass by value. The value of the variable that is passed to a function is copied into the local variable of the function. The original variable is not changed.
Passing pointers to functions Using a pointer, a function can operate on the original value instead of a copy. This is called pass by reference.</description>
    </item>
    
    <item>
      <title>Relational operators</title>
      <link>https://mcusuperuser.github.io/operators/relational/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/operators/relational/</guid>
      <description>Relational operators are binary operators that test a condition and return 1 if that condition is logically true and 0 if that condition is false.
   Operator Operation Example Result (FALSE = 0, TRUE = 1)     == Equal to a == b 1 if a equal to b, else 0   != Not equal to a != b 1 if a not equal to b, else 0   &amp;gt; Greater than a &amp;gt; b 1 if a greater than b, else 0   &amp;gt;= Greater than or equal to a &amp;gt;= b 1 if a greater than or equal to b, else 0   &amp;lt; Less than a &amp;lt; b 1 if a less than b, else 0   &amp;lt;= Less than or equal to a &amp;lt;= b 1 if a less than or equal to b, else 0    Note</description>
    </item>
    
    <item>
      <title>Tagless enumeration variable</title>
      <link>https://mcusuperuser.github.io/enums/tagless/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/enums/tagless/</guid>
      <description>If you omit the tape name, you can only have variables of that type that are specified as part of the enum declaration. Later, you cannot specify any additional variable of the enum type.
Code example
enum {JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC} current_month; </description>
    </item>
    
    <item>
      <title>Unions in memory</title>
      <link>https://mcusuperuser.github.io/unions/inmemory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/unions/inmemory/</guid>
      <description>Union variables may be declared exactly like structure variables. The big difference is that only memory is allocated to accommodate the union’s largest member. For a structure, memory is allocated to accommodate for the whole structure.
Code example
typedef union { uint8_t m; uint16_t n; uint32_t l; } myUnion; myUnion univar; </description>
    </item>
    
    <item>
      <title>Unions vs. structures</title>
      <link>https://mcusuperuser.github.io/unions/vsstructures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/unions/vsstructures/</guid>
      <description>Unions allow viewing and manipulating the same memory location using different data types. Structures enable the grouping of multiple data types and while accessing them individually.</description>
    </item>
    
    <item>
      <title>Using structure variables</title>
      <link>https://mcusuperuser.github.io/structs/using/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/structs/using/</guid>
      <description>Syntax
structVariableName.memberName; Code example
// structure to handle color values struct rgb { int red; int green; int blue; } color; int main (void){ color.red = 0; // set red portion of color  color.green = 145; // set green portion of color  blue = 189; // set blue portion of color } </description>
    </item>
    
    <item>
      <title>Extern variables</title>
      <link>https://mcusuperuser.github.io/storage/extern/</link>
      <pubDate>Wed, 23 Dec 2020 22:28:42 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/storage/extern/</guid>
      <description>The extern storage class keyword tells the compiler that the variable is defined elsewhere and will be used in the current scope. Thus, it still needs to be declared within the current scope.
A variable declared as extern outside of any function is used to indicate that the variable is defined in another source file. Memory is only allocated for it when it&amp;rsquo;s defined.
Code example main.c
extern int a; int main (void) { a = 23; .</description>
    </item>
    
    <item>
      <title>How to call a function</title>
      <link>https://mcusuperuser.github.io/func/callfunc/</link>
      <pubDate>Wed, 23 Dec 2020 22:17:28 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/func/callfunc/</guid>
      <description>Code example
foo (); // no parameters, no return value x = foo (); // no parameters, but with a return value foo (n, m); // with parameters, but no return value x = foo (n, m); // with parameters and with a return value </description>
    </item>
    
    <item>
      <title>break statement</title>
      <link>https://mcusuperuser.github.io/loops/break/</link>
      <pubDate>Wed, 23 Dec 2020 22:08:14 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/loops/break/</guid>
      <description>Syntax
break; The break statement causes immediate termination of a loop, even if the exit condition has not been met. Also, it exits from a switch statement so that execution doesn&amp;rsquo;t fall through to next case clause.
Code example
int n = 0; while (n &amp;lt; 10) { if (n == 5) break; printf(&amp;#34;Loop iteration %d\n&amp;#34;, n++); } Output
Loop iteration 0 Loop iteration 1 Loop iteration 2 Loop iteration 3 Loop iteration 4 </description>
    </item>
    
    <item>
      <title>Declaring variables</title>
      <link>https://mcusuperuser.github.io/vars/declaring/</link>
      <pubDate>Wed, 23 Dec 2020 16:49:55 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/vars/declaring/</guid>
      <description>Syntax
type identifier1, identifier2, ..., identifiern;  Variables must be declared before they can be used The type is important! It tells the compiler how much memory space to allocate and how handle the values  char myFirstLetter; int a, b, c; float currentSpeed; double sensorValue; There are multiple ways to declare a variable:
Declaration on a single line
type name; Declaration on a single line with an initial value</description>
    </item>
    
    <item>
      <title>Nesting comments</title>
      <link>https://mcusuperuser.github.io/comments/nesting/</link>
      <pubDate>Wed, 23 Dec 2020 16:26:02 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/comments/nesting/</guid>
      <description> Block comments must not be nested within other comments. Single line comments may be nested.  Code example
/*----------------------------------------------- * CMSIS-RTOS &amp;#39;main&amp;#39; function template * // comment within a comment *---------------------------------------------*/ #include &amp;#34;cmsis_os2.h&amp;#34; /* * main: initialize and start the system */ int main (void) { osKernelInitialize (); /* initialize RTOS */ LED_Initialize(); /* initialize LEDs */ /* create &amp;#39;thread&amp;#39; functions that start executing, /* another comment which doesn&amp;#39;t work */ example: tid_name=osThreadCreate (osThread(name), NULL); */ osKernelStart (); /* start thread execution */ } </description>
    </item>
    
    <item>
      <title>Declare an enumeration type with `typedef`</title>
      <link>https://mcusuperuser.github.io/enums/typedef/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/enums/typedef/</guid>
      <description>As always, variables can be declared as type typeName without requiring the keyword enum:
Syntax
typedef enum {list_of_constants} typeName; The enumeration can now be used as an ordinary data type, such as int or float.
Code example
typedef enum {JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC} month; month current_month; // Variable of type month </description>
    </item>
    
    <item>
      <title>Logical operators</title>
      <link>https://mcusuperuser.github.io/operators/logical/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/operators/logical/</guid>
      <description>Logical operators apply standard boolean algebra operations to their operands.
   Operator Operation Example Result     ! Logical NOT !a 1 if a = 0, else 0   &amp;amp;&amp;amp; Logical AND a &amp;amp;&amp;amp; b 1 if both a ≠ 0 and b ≠ 0, else 0   || Logical OR a || b 0 if both a = 0 and b = 0, else 1    </description>
    </item>
    
    <item>
      <title>Pointers and strings</title>
      <link>https://mcusuperuser.github.io/pointers/andstrings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/pointers/andstrings/</guid>
      <description>Until now, we have used arrays of char to work with strings. Using pointers, strings can be created and used in a more efficient way.
Syntax
char *name = &amp;#34;string_content&amp;#34;; Note
 Initializing a character string when it is declared is essentially the same for both a pointer and an array The NULL character \0 is automatically appended to strings in both cases  Code example
char *str = &amp;#34;Cortex&amp;#34;; At initialization, a pointer to a string points to the first character.</description>
    </item>
    
    <item>
      <title>Structure types</title>
      <link>https://mcusuperuser.github.io/structs/types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/structs/types/</guid>
      <description>Structure types can be created using a typedef.
Syntax
typedef struct structTag { type1 memberName1; ... typen memberNamen; } typeName; Note
 The structTag is optional  Code example
// structure type to handle color values typedef struct { int red; int green; int blue; } rgb; Declare a structure type variable If the typeName has already been defined, you can declare a variable of that type without the struct keyword:</description>
    </item>
    
    <item>
      <title>Register variables</title>
      <link>https://mcusuperuser.github.io/storage/register/</link>
      <pubDate>Wed, 23 Dec 2020 22:28:48 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/storage/register/</guid>
      <description>This storage class declares register variables which have the same functionality as auto variables. The only difference is that the Arm compiler v5 tries to store these variables in a register of the Arm Cortex-M core if a free register is available. This accelerates the access to the register variables. Arm compiler v6 ignores this keyword.</description>
    </item>
    
    <item>
      <title>Function prototypes</title>
      <link>https://mcusuperuser.github.io/func/prototypes/</link>
      <pubDate>Wed, 23 Dec 2020 22:17:36 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/func/prototypes/</guid>
      <description>Just like a variable, a function must be declared before it may be used. This declaration must occur before main() or any other function that uses it. The declaration may have two forms:
 The entire function definition. Just a function prototype – the function definition itself may then be placed anywhere in the program.  Code example 1
In this example, the function is declared and defined before it is used in main().</description>
    </item>
    
    <item>
      <title>continue statement</title>
      <link>https://mcusuperuser.github.io/loops/continue/</link>
      <pubDate>Wed, 23 Dec 2020 22:08:20 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/loops/continue/</guid>
      <description>Syntax
continue; The continue statement causes a program to jump back to the beginning of a loop without completing the current iteration.
Code example
int n = 0; while (n &amp;lt; 5) { if (n == 3) continue; printf(&amp;#34;Loop iteration %d\n&amp;#34;, n++); } Output
Loop iteration 0 Loop iteration 1 Loop iteration 2 Loop iteration 4 </description>
    </item>
    
    <item>
      <title>Arrays of pointers</title>
      <link>https://mcusuperuser.github.io/pointers/arraysof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/pointers/arraysof/</guid>
      <description>An array of pointers is an array variable whose elements are all be pointers.
Code example
char *str[3]; // creates an array of three pointers to char  str[0] = &amp;#34;IN&amp;#34;; str[1] = &amp;#34;OUT&amp;#34;; str[2] = &amp;#34;TRISTATE&amp;#34;; The array str[] itself is like any other array. Each element, such as str[1], is a pointers to char.
Strings will not “pack” this nicely! There will be empty locations between strings as the compiler aligns the strings in memory.</description>
    </item>
    
    <item>
      <title>Bitwise operators</title>
      <link>https://mcusuperuser.github.io/operators/bitwise/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/operators/bitwise/</guid>
      <description>Bitwise operators apply the operation to each bit of the first operand with each corresponding bit of the second operand.
   Operator Operation Example Result     ~ Bitwise NOT ~a 1, if 0 in a; 0, if 1 in a   &amp;amp; Bitwise AND a &amp;amp; b 1, if 1 in both a and b; 0, if 0 in a or b or both   | Bitwise OR a | b 1, if 1 in a or b or both; 0, if 0 in both a and b   ^ Bitwise XOR a ^ b 1, if 1 in a or b but not both; 0, if 0 or 1 in both a and b    The bitwise NOT is also known as &amp;ldquo;One&amp;rsquo;s complement&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Initialization of structure variables</title>
      <link>https://mcusuperuser.github.io/structs/initialization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/structs/initialization/</guid>
      <description>If typeName or structName have already been defined:
Syntax
typeName variableName = {const1, ..., constn}; // or struct structName variableName = {const1, ...,constn}; Code example
// structure type to handle color values typedef struct { int red; int green; int blue; } rgb; ... rgb color = {0, 145, 189}; </description>
    </item>
    
    <item>
      <title>Using an enumeration type variable</title>
      <link>https://mcusuperuser.github.io/enums/using/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/enums/using/</guid>
      <description>If the enumeration and the variable have already been defined:
Syntax
varName = labeln; Use the labels just like any other symbolic constant.
Enumeration type variables must only use the type’s labels or equivalent integer.
Code example
enum color {red, green, blue}; enum color myCar; myCar = red; myCar = 3; if (myCar == 2) { // do something } </description>
    </item>
    
    <item>
      <title>Passing parameters by value</title>
      <link>https://mcusuperuser.github.io/func/passingparams/</link>
      <pubDate>Wed, 23 Dec 2020 22:17:44 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/func/passingparams/</guid>
      <description>Parameters are passed to a function by value. These values are copied into the local parameter variables. This means, that the original variable that is passed to a function cannot be modified by the function, since only a copy of its value was passed.
Code example
int n = 5, m = 10, res; int minimum (int a, int b); int main (void) { res = minimum (n, m); // the value of n is copied into a  // the value of m is copied into b  printf(&amp;#34;The minimum is %d\n&amp;#34;, res); } int minimum (int a, int b) { return ((a &amp;lt;= b) ?</description>
    </item>
    
    <item>
      <title>Nested structures</title>
      <link>https://mcusuperuser.github.io/structs/nested/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/structs/nested/</guid>
      <description>Using the typedef structure declaration, you can nest one structure within another structure.
Code example
// declare struct type for a single point typedef struct { float x; float y; } point; // declare a struct type for a line with a start and end point typedef struct { point start; point end; } line; int main(void) { line l; l.start.x = 3.5; l.start.y = 8.4; l.end.x = 12.7; l.end.y = 18.</description>
    </item>
    
    <item>
      <title>Shift operators</title>
      <link>https://mcusuperuser.github.io/operators/shift/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/operators/shift/</guid>
      <description>Operator Operation Example Result     &amp;lt;&amp;lt; Bitwise left shift a &amp;lt;&amp;lt; b Shift a by b bits to the left   &amp;gt;&amp;gt; Bitwise right shift a &amp;gt;&amp;gt; b Shift a by b bits to the right    Bits that are shifted out are lost (in both cases).
For shift left, 0&amp;rsquo;s are shifted in (zero fill).
Code example
// Logical shift right (zero fill) // If a is unsigned: unsigned char a; a = 250; // a = 0b11111010 = 250 b = a &amp;gt;&amp;gt; 2; // b = 0b00111110 = 62  // Arithmetic shift right (sign extend) // If a is signed: char a; a = -6; // a = 0b11111010 = -6 b = a &amp;gt;&amp;gt; 2; // b = 0b11111110 = -2 Power of 2 integer divide vs.</description>
    </item>
    
    <item>
      <title>Scope of functions</title>
      <link>https://mcusuperuser.github.io/storage/scope/</link>
      <pubDate>Wed, 23 Dec 2020 22:28:53 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/storage/scope/</guid>
      <description>The scope of a function depends on it storage class, which can be either static or external. The scope of a function is either local to the file where it is defined - in case of a static function - or globally available to any file in a project - in case of an external function.
By default, functions have a global scope within a project. The extern keyword is not required, but a function prototype in the calling file (or a header file).</description>
    </item>
    
    <item>
      <title>Functions and scope</title>
      <link>https://mcusuperuser.github.io/func/scope/</link>
      <pubDate>Wed, 23 Dec 2020 22:17:51 +0100</pubDate>
      
      <guid>https://mcusuperuser.github.io/func/scope/</guid>
      <description>Scope of parameters A function&amp;rsquo;s parameters are local to the function and have no meaning outside the function itself. Parameter names may have the same identifier as a variable declared outside the function, but the parameter names will take precedence inside the function.
Code example
// The following n&amp;#39;s are not the same: int n; int absolute (int n); Scope of variables inside a function Variables that are declared inside a function are local to the function itself.</description>
    </item>
    
    <item>
      <title>Memory addressing/member access</title>
      <link>https://mcusuperuser.github.io/operators/memory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/operators/memory/</guid>
      <description>Member access operators allow access to the members of their operands.
   Operator Operation Example Result     [] Array subscript a[b] access the bth element of array a   * Pointer dereference *a The object or function a points to   &amp;amp; Address of &amp;amp;a Pointer to a   . Member access (struct/union) a.b The member b of struct or union a   -&amp;gt; Member access through pointer a-&amp;gt;b The member b of struct or union pointed to by a    This will become important when talking about arrays, pointers, structs, and unions later.</description>
    </item>
    
    <item>
      <title>Pointers to structures</title>
      <link>https://mcusuperuser.github.io/structs/pointersto/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/structs/pointersto/</guid>
      <description>There are two ways to declare a pointer to a structure. If the typeName or the structName have already been defined:
Syntax
typeName *pointerName; // or struct structName *pointerName; Code example
// structure type to handle color values typedef struct { int red; int green; int blue; } rgb; ... rgb *pColor; Code example
// structure type to handle color values struct rgb { int red; int green; int blue; } .</description>
    </item>
    
    <item>
      <title>Creating arrays of structures</title>
      <link>https://mcusuperuser.github.io/structs/arraysof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/structs/arraysof/</guid>
      <description>There are two ways to create arrays of structures. If the typeName or the structName have already been defined:
Syntax
typeName arrayName[n]; // or struct structName arrayName[n]; Code example
// structure type to handle color values typedef struct { int red; int green; int blue; } rgb; ... rgb aColor[2]; </description>
    </item>
    
    <item>
      <title>Other operators</title>
      <link>https://mcusuperuser.github.io/operators/other/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/operators/other/</guid>
      <description>Operator Operation Example Result     (...) Function call f(...) Calls the function f(), with specified arguments   , Comma operator a, b Evaluates a then b, else result is value of b   (type) Type cast (type)a Casts the type of a to type   ? : Conditional operator a ? b : c The value of b if a is true, else value of c   sizeof Sizeof operator sizeof a The size in bytes of a    The conditional operator Syntax</description>
    </item>
    
    <item>
      <title>Initializing arrays of structures at declaration</title>
      <link>https://mcusuperuser.github.io/structs/initarraysof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/structs/initarraysof/</guid>
      <description>If the typeName or the structName have already been defined:
Syntax
typeName arrayName[n] = {{list1}, ..., {listn}}; // or struct structName arrayName[n] = {{list1}, ..., {listn}}; Code example
// structure type to handle color values typedef struct { int red; int green; int blue; } rgb; ... rgb aColor[2] = {{0, 0, 0}, {255, 255, 255}}; </description>
    </item>
    
    <item>
      <title>Operator precedence</title>
      <link>https://mcusuperuser.github.io/operators/precedence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/operators/precedence/</guid>
      <description>The following table lists the precedence and associativity of C operators. Operators are listed top to bottom, in descending precedence. Conflicts between operators with the same precedence are handled via the rules of associativity.
   Precedence Operator Description Associativity     1 ++ -- Suffix/postfix increment and decrement Left-to-right    () Function call     [] Array subscripting     .</description>
    </item>
    
    <item>
      <title>Using arrays of structures</title>
      <link>https://mcusuperuser.github.io/structs/usingarraysof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/structs/usingarraysof/</guid>
      <description>If the arrayName has already been defined:
Syntax
arrayName[n].memberName Code example
// structure type to handle color values typedef struct { int red; int green; int blue; } rgb; ... rgb aColor[2] = {{0, 0, 0}, {255, 255, 255}}; int main (void) { aColor[0].red = 0; aColor[0].green = 145; aColor[0].blue = 189; ... } </description>
    </item>
    
    <item>
      <title>Passing structures to functions</title>
      <link>https://mcusuperuser.github.io/structs/passingtofuncs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mcusuperuser.github.io/structs/passingtofuncs/</guid>
      <description>Code example
// structure type to handle color values typedef struct { int red; int green; int blue; } rgb; void show_rgb (rgb n) { printf(&amp;#34;(%d, %d, %d)\n&amp;#34;, n.reg, n.green, n.blue); } int main (void) { rgb a = {0, 145, 198}; rgb b = {0, 255, 255}; show_rgb (a); show_rgb (b); } </description>
    </item>
    
  </channel>
</rss>
